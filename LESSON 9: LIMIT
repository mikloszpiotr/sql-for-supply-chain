-- ============================================================================
-- LESSON 9: LIMIT/TOP for Sample Data
-- ============================================================================
-- LIMIT (MySQL, PostgreSQL) and TOP (SQL Server) allow you to restrict
-- the number of rows returned by a query.
--
-- Why this matters in supply chain:
-- - Finding top 10 best-selling products
-- - Identifying bottom 20 slow-moving items
-- - Getting first 100 orders for review
-- - Sampling data for testing
-- - Pagination in applications
-- - Performance optimization (don't fetch all data when you need a sample)
--
-- Syntax varies by database:
-- MySQL/PostgreSQL: LIMIT n
-- SQL Server: TOP n
-- Oracle: ROWNUM or FETCH FIRST n ROWS
-- ============================================================================


-- ----------------------------------------------------------------------------
-- PART 1: BASIC LIMIT/TOP USAGE
-- ----------------------------------------------------------------------------

-- Example 1: Get first 10 products (MySQL/PostgreSQL)

SELECT product_id, product_name, category, price
FROM products
LIMIT 10;

-- SQL Server equivalent:
-- SELECT TOP 10 product_id, product_name, category, price
-- FROM products;

-- Results (first 10 rows):
-- product_id | product_name        | category    | price
-- -----------|---------------------|-------------|-------
-- 1001       | Widget A            | Electronics | 29.99
-- 1002       | Gadget B            | Tools       | 15.50
-- 1003       | Component C         | Electronics | 99.99
-- 1004       | Tool Set D          | Tools       | 125.00
-- 1005       | Part E              | Parts       | 8.75
-- 1006       | Smart Device        | Electronics | 249.99
-- 1007       | Assembly Kit        | Electronics | 150.00
-- 1008       | Circuit Board       | Electronics | 175.50
-- 1009       | Mini Widget         | Tools       | 45.50
-- 1010       | Premium Gadget      | Electronics | 399.99
--
-- Use case: Quick data sample or testing query results
-- Without ORDER BY, order is unpredictable


-- Example 2: Get top 5 most expensive products
-- LIMIT with ORDER BY for meaningful results

SELECT product_id, product_name, price, category
FROM products
ORDER BY price DESC
LIMIT 5;

-- SQL Server:
-- SELECT TOP 5 product_id, product_name, price, category
-- FROM products
-- ORDER BY price DESC;

-- Results:
-- product_id | product_name        | price  | category
-- -----------|---------------------|--------|----------
-- 1010       | Premium Gadget      | 399.99 | Electronics
-- 1006       | Smart Device        | 249.99 | Electronics
-- 1008       | Circuit Board       | 175.50 | Electronics
-- 1007       | Assembly Kit        | 150.00 | Electronics
-- 1004       | Tool Set D          | 125.00 | Tools
--
-- Use case: Premium product showcase
-- Feature most expensive items in catalog


-- Example 3: Get 5 cheapest products
-- Budget-friendly items

SELECT product_id, product_name, price, category
FROM products
ORDER BY price ASC
LIMIT 5;

-- Results:
-- product_id | product_name    | price | category
-- -----------|-----------------|-------|----------
-- 1005       | Part E          | 8.75  | Parts
-- 1002       | Gadget B        | 15.50 | Tools
-- 1001       | Widget A        | 29.99 | Electronics
-- 1009       | Mini Widget     | 45.50 | Tools
-- 1012       | Component X     | 67.50 | Parts
--
-- Use case: Budget product recommendations
-- Entry-level or promotional items


-- Example 4: Get most recent 20 orders
-- Latest order activity

SELECT order_id, customer_id, order_date, total, status
FROM orders
ORDER BY order_date DESC
LIMIT 20;

-- Results (20 most recent):
-- order_id | customer_id | order_date  | total   | status
-- ---------|-------------|-------------|---------|----------
-- 5125     | C890        | 2024-01-25  | 3200.00 | Processing
-- 5124     | C456        | 2024-01-25  | 450.00  | Pending
-- 5123     | C234        | 2024-01-24  | 1200.00 | Shipped
-- 5122     | C789        | 2024-01-24  | 875.50  | Processing
-- ... (16 more rows)
--
-- Use case: Operations dashboard showing recent activity
-- Monitor latest orders for quick action


-- Example 5: Get oldest 15 orders still pending
-- FIFO order fulfillment priority

SELECT order_id, customer_id, order_date, total
FROM orders
WHERE status = 'Pending'
ORDER BY order_date ASC
LIMIT 15;

-- Results:
-- order_id | customer_id | order_date  | total
-- ---------|-------------|-------------|--------
-- 5002     | C456        | 2024-01-10  | 230.50
-- 5008     | C123        | 2024-01-12  | 450.00
-- 5015     | C789        | 2024-01-14  | 1200.00
-- ... (12 more rows)
--
-- Use case: Processing backlog
-- Oldest pending orders should be handled first


-- ----------------------------------------------------------------------------
-- PART 2: TOP SELLERS AND BEST PERFORMERS
-- ----------------------------------------------------------------------------

-- Example 6: Top 10 best-selling products by quantity
-- Requires aggregation with sales data

SELECT 
    p.product_id,
    p.product_name,
    p.category,
    SUM(od.quantity) AS total_quantity_sold,
    COUNT(DISTINCT od.order_id) AS number_of_orders
FROM products p
JOIN order_details od ON p.product_id = od.product_id
GROUP BY p.product_id, p.product_name, p.category
ORDER BY total_quantity_sold DESC
LIMIT 10;

-- Results:
-- product_id | product_name    | category    | total_quantity_sold | number_of_orders
-- -----------|-----------------|-------------|---------------------|------------------
-- 1001       | Widget A        | Electronics | 1250                | 245
-- 1002       | Gadget B        | Tools       | 980                 | 198
-- 1005       | Part E          | Parts       | 875                 | 156
-- 1003       | Component C     | Electronics | 750                 | 180
-- 1009       | Mini Widget     | Tools       | 680                 | 134
-- 1006       | Smart Device    | Electronics | 450                 | 98
-- 1012       | Component X     | Parts       | 420                 | 87
-- 1015       | Tool Kit        | Tools       | 380                 | 76
-- 1018       | Assembly Part   | Parts       | 350                 | 72
-- 1020       | Sensor Unit     | Electronics | 340                 | 68
--
-- Use case: Inventory planning focus
-- Ensure best sellers are always in stock


-- Example 7: Top 10 products by revenue
-- Highest revenue generators

SELECT 
    p.product_id,
    p.product_name,
    p.price,
    SUM(od.quantity) AS units_sold,
    SUM(od.quantity * od.unit_price) AS total_revenue
FROM products p
JOIN order_details od ON p.product_id = od.product_id
GROUP BY p.product_id, p.product_name, p.price
ORDER BY total_revenue DESC
LIMIT 10;

-- Results:
-- product_id | product_name    | price  | units_sold | total_revenue
-- -----------|-----------------|--------|------------|---------------
-- 1010       | Premium Gadget  | 399.99 | 125        | 49998.75
-- 1001       | Widget A        | 29.99  | 1250       | 37487.50
-- 1006       | Smart Device    | 249.99 | 450        | 112495.50
-- 1003       | Component C     | 99.99  | 750        | 74992.50
-- 1008       | Circuit Board   | 175.50 | 280        | 49140.00
-- 1004       | Tool Set D      | 125.00 | 350        | 43750.00
-- 1007       | Assembly Kit    | 150.00 | 280        | 42000.00
-- 1002       | Gadget B        | 15.50  | 980        | 15190.00
-- 1015       | Tool Kit        | 89.99  | 380        | 34196.20
-- 1020       | Sensor Unit     | 125.00 | 340        | 42500.00
--
-- Use case: Revenue optimization
-- Focus marketing on highest revenue products


-- Example 8: Top 5 customers by total spending
-- VIP customer identification

SELECT 
    c.customer_id,
    c.customer_name,
    c.email,
    COUNT(o.order_id) AS total_orders,
    SUM(o.total) AS total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.customer_name, c.email
ORDER BY total_spent DESC
LIMIT 5;

-- Results:
-- customer_id | customer_name    | email              | total_orders | total_spent
-- ------------|------------------|--------------------|--------------|-------------
-- C123        | John Smith       | john@email.com     | 45           | 125000.50
-- C456        | Sarah Johnson    | sarah@email.com    | 38           | 98750.25
-- C789        | TechCorp Inc     | tech@corp.com      | 52           | 87500.00
-- C234        | Global Supply    | info@global.com    | 31           | 75250.75
-- C890        | Premium Buyers   | buy@premium.com    | 28           | 68900.00
--
-- Use case: Customer relationship management
-- VIP treatment, exclusive offers, account management


-- Example 9: Top 10 suppliers by product count
-- Most diverse supplier relationships

SELECT 
    s.supplier_id,
    s.supplier_name,
    s.country,
    COUNT(p.product_id) AS products_supplied,
    AVG(p.price) AS avg_product_price
FROM suppliers s
JOIN products p ON s.supplier_id = p.supplier_id
GROUP BY s.supplier_id, s.supplier_name, s.country
ORDER BY products_supplied DESC
LIMIT 10;

-- Results:
-- supplier_id | supplier_name     | country       | products_supplied | avg_product_price
-- ------------|-------------------|---------------|-------------------|-------------------
-- 501         | ABC Manufacturing | United States | 45                | 125.50
-- 502         | XYZ Components    | China         | 38                | 89.99
-- 505         | Premium Supplies  | Germany       | 32                | 175.25
-- 503         | Global Supply Co  | Germany       | 28                | 95.00
-- 510         | Quality Parts     | China         | 25                | 67.50
-- 508         | US Parts Inc      | United States | 22                | 110.00
-- 512         | Regional Dist     | Canada        | 18                | 85.75
-- 515         | Euro Supplies     | France        | 15                | 145.00
-- 507         | Asia Pacific      | Japan         | 12                | 200.00
-- 520         | Local Vendor      | United States | 10                | 55.50
--
-- Use case: Supplier consolidation analysis
-- Major supplier relationships


-- Example 10: Top 20 highest value orders
-- Large order tracking

SELECT 
    order_id,
    customer_id,
    order_date,
    total,
    status,
    ROUND(total, 2) AS formatted_total
FROM orders
ORDER BY total DESC
LIMIT 20;

-- Results:
-- order_id | customer_id | order_date  | total    | status      | formatted_total
-- ---------|-------------|-------------|----------|-------------|----------------
-- 5089     | C123        | 2024-01-20  | 15500.00 | Delivered   | 15500.00
-- 5112     | C789        | 2024-01-22  | 12800.00 | Processing  | 12800.00
-- 5095     | C456        | 2024-01-18  | 11250.00 | Shipped     | 11250.00
-- 5103     | C234        | 2024-01-21  | 9875.50  | Delivered   | 9875.50
-- ... (16 more rows)
--
-- Use case: High-value order special handling
-- May require manager approval or white-glove service


-- ----------------------------------------------------------------------------
-- PART 3: SLOW MOVERS AND BOTTOM PERFORMERS
-- ----------------------------------------------------------------------------

-- Example 11: Bottom 20 slow-moving products
-- Least sold items

SELECT 
    p.product_id,
    p.product_name,
    p.category,
    p.price,
    COALESCE(SUM(od.quantity), 0) AS total_quantity_sold,
    COUNT(DISTINCT od.order_id) AS number_of_orders
FROM products p
LEFT JOIN order_details od ON p.product_id = od.product_id
GROUP BY p.product_id, p.product_name, p.category, p.price
ORDER BY total_quantity_sold ASC
LIMIT 20;

-- Results:
-- product_id | product_name       | category  | price  | total_quantity_sold | number_of_orders
-- -----------|--------------------|-----------|--------|---------------------|------------------
-- 1085       | Obsolete Part      | Parts     | 125.00 | 0                   | 0
-- 1092       | Legacy Component   | Parts     | 89.99  | 0                   | 0
-- 1067       | Old Model Widget   | Tools     | 45.50  | 2                   | 2
-- 1078       | Discontinued Item  | Parts     | 67.50  | 3                   | 2
-- 1055       | Slow Mover A       | Tools     | 32.50  | 5                   | 3
-- ... (15 more rows)
--
-- Use case: Inventory optimization
-- Consider discontinuing or running promotions on slow movers


-- Example 12: Bottom 15 products by revenue
-- Lowest revenue generators

SELECT 
    p.product_id,
    p.product_name,
    p.price,
    COALESCE(SUM(od.quantity), 0) AS units_sold,
    COALESCE(SUM(od.quantity * od.unit_price), 0) AS total_revenue
FROM products p
LEFT JOIN order_details od ON p.product_id = od.product_id
GROUP BY p.product_id, p.product_name, p.price
ORDER BY total_revenue ASC
LIMIT 15;

-- Results:
-- product_id | product_name       | price  | units_sold | total_revenue
-- -----------|--------------------|--------|------------|---------------
-- 1085       | Obsolete Part      | 125.00 | 0          | 0.00
-- 1092       | Legacy Component   | 89.99  | 0          | 0.00
-- 1067       | Old Model Widget   | 45.50  | 2          | 91.00
-- 1078       | Discontinued Item  | 67.50  | 3          | 202.50
-- 1055       | Slow Mover A       | 32.50  | 5          | 162.50
-- ... (10 more rows)
--
-- Use case: Product line rationalization
-- May need to discontinue or clear out these items


-- Example 13: Products with lowest stock turnover
-- Items sitting in inventory longest

SELECT 
    i.product_id,
    p.product_name,
    i.quantity AS current_stock,
    COALESCE(SUM(od.quantity), 0) AS total_sold_last_90_days,
    CASE 
        WHEN SUM(od.quantity) > 0 THEN ROUND(i.quantity * 90.0 / SUM(od.quantity), 1)
        ELSE 999
    END AS days_of_stock
FROM inventory i
JOIN products p ON i.product_id = p.product_id
LEFT JOIN order_details od ON i.product_id = od.product_id 
    AND od.order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 90 DAY)
GROUP BY i.product_id, p.product_name, i.quantity
ORDER BY days_of_stock DESC
LIMIT 20;

-- Results:
-- product_id | product_name       | current_stock | total_sold_last_90_days | days_of_stock
-- -----------|--------------------|---------------|-------------------------|---------------
-- 1085       | Obsolete Part      | 150           | 0                       | 999.0
-- 1092       | Legacy Component   | 89            | 0                       | 999.0
-- 1067       | Old Model Widget   | 200           | 5                       | 3600.0
-- 1078       | Discontinued Item  | 125           | 8                       | 1406.3
-- 1055       | Slow Mover A       | 75            | 12                      | 562.5
-- ... (15 more rows)
--
-- Use case: Working capital optimization
-- High days_of_stock = cash tied up in slow-moving inventory


-- Example 14: Lowest performing warehouses by volume
-- Warehouses with least activity

SELECT 
    w.warehouse_id,
    w.warehouse_name,
    w.city,
    w.state,
    COUNT(DISTINCT o.order_id) AS orders_fulfilled,
    COALESCE(SUM(od.quantity), 0) AS total_units_shipped
FROM warehouses w
LEFT JOIN shipments s ON w.warehouse_id = s.warehouse_id
LEFT JOIN orders o ON s.order_id = o.order_id
LEFT JOIN order_details od ON o.order_id = od.order_id
GROUP BY w.warehouse_id, w.warehouse_name, w.city, w.state
ORDER BY orders_fulfilled ASC
LIMIT 10;

-- Results:
-- warehouse_id | warehouse_name  | city      | state | orders_fulfilled | total_units_shipped
-- -------------|-----------------|-----------|-------|------------------|--------------------
-- WH07         | Rural DC        | Boise     | ID    | 45               | 1250
-- WH09         | Small Hub       | Portland  | ME    | 67               | 1890
-- WH06         | Regional Center | Omaha     | NE    | 89               | 2450
-- ... (7 more rows)
--
-- Use case: Distribution network optimization
-- May consider closing or repurposing low-volume facilities


-- Example 15: Suppliers with fewest orders
-- Underutilized supplier relationships

SELECT 
    s.supplier_id,
    s.supplier_name,
    s.country,
    COUNT(DISTINCT po.purchase_order_id) AS purchase_orders_placed,
    COALESCE(SUM(po.total_amount), 0) AS total_spending
FROM suppliers s
LEFT JOIN purchase_orders po ON s.supplier_id = po.supplier_id
    AND po.order_date >= DATE_SUB(CURRENT_DATE, INTERVAL 365 DAY)
GROUP BY s.supplier_id, s.supplier_name, s.country
ORDER BY purchase_orders_placed ASC
LIMIT 15;

-- Results:
-- supplier_id | supplier_name      | country | purchase_orders_placed | total_spending
-- ------------|--------------------|---------|-----------------------|----------------
-- 525         | Inactive Supplier  | USA     | 0                     | 0.00
-- 518         | Rarely Used Co     | China   | 1                     | 2500.00
-- 522         | Backup Vendor      | Mexico  | 2                     | 4750.00
-- ... (12 more rows)
--
-- Use case: Supplier relationship management
-- Consider consolidating or removing inactive suppliers


-- ----------------------------------------------------------------------------
-- PART 4: PAGINATION AND OFFSET
-- ----------------------------------------------------------------------------

-- Example 16: First 100 orders (page 1)
-- Basic pagination

SELECT order_id, customer_id, order_date, total, status
FROM orders
ORDER BY order_date DESC
LIMIT 100;

-- Results: Orders 1-100
-- Use case: First page of order list


-- Example 17: Orders 101-200 (page 2)
-- Using OFFSET for pagination

SELECT order_id, customer_id, order_date, total, status
FROM orders
ORDER BY order_date DESC
LIMIT 100 OFFSET 100;

-- SQL Server equivalent:
-- SELECT order_id, customer_id, order_date, total, status
-- FROM orders
-- ORDER BY order_date DESC
-- OFFSET 100 ROWS
-- FETCH NEXT 100 ROWS ONLY;

-- Results: Orders 101-200
-- Use case: Second page of order list


-- Example 18: Orders 201-300 (page 3)

SELECT order_id, customer_id, order_date, total, status
FROM orders
ORDER BY order_date DESC
LIMIT 100 OFFSET 200;

-- Results: Orders 201-300
-- Use case: Third page of order list


-- Example 19: Generic pagination formula
-- Page N, showing M records per page

-- Page 1 (records 1-50):
SELECT * FROM orders ORDER BY order_id LIMIT 50 OFFSET 0;

-- Page 2 (records 51-100):
SELECT * FROM orders ORDER BY order_id LIMIT 50 OFFSET 50;

-- Page 3 (records 101-150):
SELECT * FROM orders ORDER BY order_id LIMIT 50 OFFSET 100;

-- Formula: OFFSET = (page_number - 1) * records_per_page
-- Example: Page 5, 50 per page = OFFSET 200


-- Example 20: Products with pagination - 25 per page

-- Page 1:
SELECT product_id, product_name, price, category
FROM products
ORDER BY product_name
LIMIT 25 OFFSET 0;

-- Page 2:
SELECT product_id, product_name, price, category
FROM products
ORDER BY product_name
LIMIT 25 OFFSET 25;

-- Page 3:
SELECT product_id, product_name, price, category
FROM products
ORDER BY product_name
LIMIT 25 OFFSET 50;

-- Use case: Product catalog with pages
-- Typical e-commerce or admin interface pattern


-- ----------------------------------------------------------------------------
-- PART 5: SAMPLING AND DATA EXPLORATION
-- ----------------------------------------------------------------------------

-- Example 21: Random sample of 50 products for testing
-- Using RAND() or RANDOM() for sampling

SELECT product_id, product_name, category, price
FROM products
ORDER BY RAND()  -- MySQL
-- ORDER BY RANDOM()  -- PostgreSQL
LIMIT 50;

-- Results: 50 random products
-- Use case: Quality assurance testing
-- Representative sample without bias


-- Example 22: Sample 100 orders for audit
-- Random order selection

SELECT order_id, customer_id, order_date, total
FROM orders
WHERE order_date >= '2024-01-01'
ORDER BY RAND()
LIMIT 100;

-- Use case: Financial audit sample
-- Statistical sampling for compliance


-- Example 23: First 10 products in each category
-- Using window functions with LIMIT concept

SELECT product_id, product_name, category, price, row_num
FROM (
    SELECT 
        product_id,
        product_name,
        category,
        price,
        ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) AS row_num
    FROM products
) ranked
WHERE row_num <= 10
ORDER BY category, row_num;

-- Results: Top 10 in Electronics, Top 10 in Tools, etc.
-- Use case: Category-specific top performers


-- Example 24: Quick data preview (first 20 rows)
-- Initial data exploration

SELECT *
FROM inventory
LIMIT 20;

-- Use case: Developer testing or data analyst exploration
-- Quick look at table structure and sample data


-- Example 25: Count total records vs sample
-- Understanding what LIMIT represents

-- Total count:
SELECT COUNT(*) AS total_products FROM products;
-- Result: 1250 products

-- Sample:
SELECT * FROM products LIMIT 100;
-- Returns: 100 products (8% of total)

-- Showing both:
SELECT 
    (SELECT COUNT(*) FROM products) AS total_products,
    'Showing' AS description,
    100 AS sample_size,
    ROUND(100.0 * 100 / (SELECT COUNT(*) FROM products), 1) AS percent_shown;

-- Results:
-- total_products | description | sample_size | percent_shown
-- ---------------|-------------|-------------|---------------
-- 1250           | Showing     | 100         | 8.0


-- ----------------------------------------------------------------------------
-- PART 6: COMBINING LIMIT WITH FILTERS
-- ----------------------------------------------------------------------------

-- Example 26: Top 10 Electronics by price

SELECT product_id, product_name, price, category
FROM products
WHERE category = 'Electronics'
ORDER BY price DESC
LIMIT 10;

-- Results: Only Electronics, top 10 by price
-- Use case: Category-specific premium items


-- Example 27: Top 15 pending orders by value

SELECT order_id, customer_id, total, order_date
FROM orders
WHERE status = 'Pending'
ORDER BY total DESC
LIMIT 15;

-- Use case: High-value pending orders needing attention
-- Priority processing list


-- Example 28: Bottom 10 stock levels (excluding zero)

SELECT product_id, product_name, quantity, warehouse_id
FROM inventory
WHERE quantity > 0
ORDER BY quantity ASC
LIMIT 10;

-- Results: 10 lowest non-zero stock items
-- Use case: Reorder priority excluding out-of-stock


-- Example 29: Most recent 25 delivered orders

SELECT order_id, customer_id, order_date, delivery_date, total
FROM orders
WHERE status = 'Delivered'
ORDER BY delivery_date DESC
LIMIT 25;

-- Use case: Recent fulfillment performance review


-- Example 30: Top 20 customers from specific region

SELECT 
    c.customer_id,
    c.customer_name,
    c.state,
    COUNT(o.order_id) AS order_count,
    SUM(o.total) AS total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE c.state IN ('CA', 'NY', 'TX')
GROUP BY c.customer_id, c.customer_name, c.state
ORDER BY total_spent DESC
LIMIT 20;

-- Use case: Regional VIP customer analysis
-- Top spenders in key markets


-- ----------------------------------------------------------------------------
-- PART 7: PERFORMANCE CONSIDERATIONS
-- ----------------------------------------------------------------------------

-- Example 31: Efficient top N query with index

-- GOOD: Uses index on price, returns quickly
SELECT product_id, product_name, price
FROM products
ORDER BY price DESC
LIMIT 10;

-- BAD: OFFSET too large, slow performance
SELECT product_id, product_name, price
FROM products
ORDER BY price DESC
LIMIT 10 OFFSET 100000;  -- Scans 100,000+ rows to skip them

-- BETTER: Use WHERE clause instead of large OFFSET
SELECT product_id, product_name, price
FROM products
WHERE price < (SELECT MIN(price) FROM (
    SELECT price FROM products ORDER BY price DESC LIMIT 10000
) subquery)
ORDER BY price DESC
LIMIT 10;


-- Example 32: Counting before limiting
-- Know what you're missing

SELECT 
    COUNT(*) OVER() AS total_count,
    product_id,
    product_name,
    price
FROM products
ORDER BY price DESC
LIMIT 10;

-- Results show total count in each row:
-- total_count | product_id | product_name    | price
-- ------------|------------|-----------------|-------
-- 1250        | 1010       | Premium Gadget  | 399.99
-- 1250        | 1006       | Smart Device    | 249.99
-- ... (shows you're seeing 10 of 1250)


-- ============================================================================
-- LIMIT/TOP SYNTAX BY DATABASE
-- ============================================================================

-- MySQL / PostgreSQL / SQLite:
SELECT * FROM products ORDER BY price DESC LIMIT 10;
SELECT * FROM products ORDER BY price DESC LIMIT 10 OFFSET 20;

-- SQL Server:
-- SELECT TOP 10 * FROM products ORDER BY price DESC;
-- SELECT * FROM products ORDER BY price DESC 
-- OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;

-- Oracle (older versions):
-- SELECT * FROM (
--     SELECT * FROM products ORDER BY price DESC
-- ) WHERE ROWNUM <= 10;

-- Oracle (newer versions):
-- SELECT * FROM products ORDER BY price DESC FETCH FIRST 10 ROWS ONLY;
-- SELECT * FROM products ORDER BY price DESC 
-- OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;


-- ============================================================================
-- BEST PRACTICES
-- ============================================================================

-- 1. Always use ORDER BY with LIMIT (otherwise results are unpredictable)
-- 2. Be careful with large OFFSET values (performance issue)
-- 3. Use LIMIT for pagination in applications
-- 4. Consider total count for user interfaces (show "Page 1 of 50")
-- 5. Index columns used in ORDER BY for performance
-- 6. Use LIMIT for development/testing on large tables
-- 7. Combine with WHERE to filter before limiting


-- ============================================================================
-- COMMON MISTAKES TO AVOID
-- ============================================================================

-- WRONG: LIMIT without ORDER BY (unpredictable results)
-- SELECT * FROM products LIMIT 10;
-- You get "some" 10 products, but which ones? Order is not guaranteed

-- CORRECT: Always specify order
SELECT * FROM products ORDER BY product_id LIMIT 10;


-- WRONG: Very large OFFSET (slow performance)
-- SELECT * FROM orders LIMIT 10 OFFSET 1000000;
-- Database must scan 1,000,000 rows to skip them

-- CORRECT: Use keyset pagination instead
SELECT * FROM orders 
WHERE order_id > 1000000  -- last_seen_id from previous page
ORDER BY order_id 
LIMIT 10;


-- WRONG: Different ORDER BY on different pages
-- Page 1: SELECT * FROM products ORDER BY price LIMIT 10;
-- Page 2: SELECT * FROM products ORDER BY product_name LIMIT 10 OFFSET 10;
-- Results inconsistent across pages

-- CORRECT: Same ORDER BY for all pages
SELECT * FROM products ORDER BY price LIMIT 10 OFFSET 0;  -- Page 1
SELECT * FROM products ORDER BY price LIMIT 10 OFFSET 10; -- Page 2


-- WRONG: Not considering ties in ORDER BY
-- SELECT * FROM products ORDER BY price LIMIT 10;
-- If multiple products have same price, which ones appear?

-- CORRECT: Add tiebreaker column
SELECT * FROM products ORDER BY price DESC, product_id ASC LIMIT 10;


-- ============================================================================
-- PRACTICE EXERCISES
-- ============================================================================

-- Exercise 1: Get top 5 customers by number of orders
-- SELECT customer_id, customer_name, COUNT(order_id) AS order_count
-- FROM customers c JOIN orders o ON c.customer_id = o.customer_id
-- GROUP BY customer_id, customer_name
-- ORDER BY order_count DESC
-- LIMIT 5;


-- Exercise 2: Find bottom 10 products by sales quantity
-- SELECT p.product_id, p.product_name, COALESCE(SUM(od.quantity), 0) AS total_sold
-- FROM products p
-- LEFT JOIN order_details od ON p.product_id = od.product_id
-- GROUP BY p.product_id, p.product_name
-- ORDER BY total_sold ASC
-- LIMIT 10;


-- Exercise 3: Get orders 51-75 (page 3, 25 per page)
-- SELECT order_id, customer_id, order_date, total
-- FROM orders
-- ORDER BY order_date DESC
-- LIMIT 25 OFFSET 50;


-- Exercise 4: Top 20 most expensive items in Tools category
-- SELECT product_id, product_name, price
-- FROM products
-- WHERE category = 'Tools'
-- ORDER BY price DESC
-- LIMIT 20;
